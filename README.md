# 科学の甲子園 非公式競技

・競技参加者がすること
1.候補8人の実力をみて、高得点を取りやすそうな6人を決める方法を考える
2.いざ問題を解くとき、参加者6人の実力と問題の難しさを参考にして、
　それぞれの人が取り組む問題の順番を考える

・目標
 12問の得点の合計を最大化すること

・プログラムの実行フロー
1.inFunc()が呼び出され、8人の実力が与えられる
1.参加者の書いたmemberFunc()が呼び出され、筆記競技に参加するメンバーを決定する(この時点では、問題の難易度は分からない)
1.diffFunc()が呼び出され、各問題の難易度が与えられる
1.参加者の書いたmoveFunc()が呼び出され、2で決めた参加者が、それぞれどの順で問題を解くかを決定する
1.120ターン分のシミュレーションが実行され、結果が出力される

・include
　iostream/vector/algorithm以外を使いたい人は最上部にincludeを追記？

・inFunc()
 メンバー候補8人の、科目0~5までに対する得意さを返す
 値が大きいほど得意
 テストケースの実行時に呼ばれる
 手元で書き換える必要はなし

・diffFunc()
 問題0~11の難しさを返す
 値が大きいほど時間がかかる
 テストケースの実行時に呼ばれる
 手元で書き換える必要はなし

・memberFunc()
 inFunc()で返された値を受け取る
 8人の候補のうちから筆記競技に参加する6人の番号を返す
 要素数6の1次元配列を返す
 提出する関数なので、いろいろ試すとよい

・moveFunc()
 参加する6人の実力（isFunc()の値のうち、memberFunc()で選ばれた6人の値）および、
 問題0~11の難しさ（diffFunc()）を受け取る
 （問題の難しさは、参加者が見積もった難しさ？）
 6人それぞれについて、12問に手を付ける順番を決めて返す　
 要素数6×12の2次元配列を返す（vec[0]の要素数が12）
 提出する関数なので、いろいろ試すとよい

・main()
 memberFunc(),moveFunc()で決められた値を受け取り、
 1分単位で行動をシミュレートする
 各科目iに対して、問題2×i,2×i+1の2問が用意されている
 問題各題に対して30点、合計360点の配点



 ・templateに使用されている変数
 indata[i][j]:候補iの、問題分野jに対する得意さ
 diff[i]:問題iの難しさ
 member:競技に参加する人の配列
 result:合計得点
 flag:参加者に同じ人が含まれていないかどうか
 pNum:参加者の人数（最大6人）
 problems:問題数（必ず12問）
 joined[i]:候補iが既に選ばれているかどうか
 joinedAbility[i][j]:参加者i(候補iとは限らない)の、問題分野jに対する得意さ 
 Mout[i][j]:参加者iがj番目に手を付ける問題番号
 cur[i]:問題iの現在の進捗度（0~30）
 action[i]:参加者iが既に何問解き終わったか
 dPrgsSum[i]:同じターンに問題iを解く人が産む進捗度の和
 solverNums[i]:同じターンに問題iを解く人の総和
